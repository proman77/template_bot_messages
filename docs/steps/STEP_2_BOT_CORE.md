3.  Реализовать механизм **Auto-Registration**: автоматическое сохранение/обновление пользователя в БД при любой активности.
4.  Реализовать обработку событий блокировки бота (**Chat Member Events**) для поддержания актуальности базы рассылки.

---

## 1. Конфигурация и Инициализация (Core Setup)

### 1.1. Экземпляр Бота
*   Бот должен инициализироваться с токеном, полученным из конфигурационного файла (через `Dynaconf`).
*   **Режим парсинга:** По умолчанию установить `HTML` для всех сообщений.

### 1.2. Хранилище Состояний (FSM Storage)
*   Использовать **NATS (JetStream)** в качестве бэкенда для FSM (`NatsStorage`).
*   Хранение состояний в оперативной памяти (`MemoryStorage`) **запрещено**, так как это нарушает принцип stateless-архитектуры и не позволяет масштабировать количество контейнеров с ботом.
*   Использовать `DefaultKeyBuilder` с настройкой `with_destiny=True` для корректной работы в диалогах.

### 1.3. Диспетчер (Dispatcher)
*   Подключить роутеры (Routers) для разделения логики (команды, диалоги, события админки).
*   Обеспечить корректное закрытие соединений (NATS, Redis, DB) при остановке бота (`shutdown` events).

---

## 2. Слой Middleware (Промежуточное ПО)

Middleware — это ключевой компонент архитектуры, который перехватывает апдейты *до* того, как они попадут в хендлеры.

### 2.1. Middleware БД (Database Session DI)
*   **Тип:** Outer Middleware (внешняя мидлварь).
*   **Задача:** Создавать новую асинхронную сессию SQLAlchemy для **каждого** входящего обновления (Update) и передавать её в аргументы хендлера.
*   **Жизненный цикл:**
    1.  Получить апдейт.
    2.  Открыть транзакцию/сессию.
    3.  Передать управление дальше (в хендлер).
    4.  После выполнения хендлера автоматически закрыть сессию (commit или rollback в случае ошибки).

### 2.2. Middleware Трекинга (User Tracking)
*   **Цель:** Гарантировать, что любой пользователь, взаимодействующий с ботом, существует в БД.
*   **Триггеры:** Сообщения (`Message`) и Нажатия кнопок (`CallbackQuery`).
*   **Логика (Upsert - Update or Insert):**
    1.  Извлечь данные пользователя (`id`, `username`, `fullname`, `language`) из объекта Telegram.
    2.  Выполнить запрос к БД (`INSERT ... ON CONFLICT DO UPDATE`):
        *   Если пользователя нет — создать.
        *   Если пользователь есть — обновить поля `updated_at`, `username`, `fullname` (на случай смены никнейма) и выставить `is_active = True`.
    3.  Эта операция должна быть максимально быстрой, чтобы не замедлять ответ бота.

---

## 3. Обработка Статусов (Chat Member Updates)

Это критически важная часть для системы рассылок. Бот должен знать, кто его заблокировал, чтобы не отправлять сообщения "в пустоту".

### 3.1. Событие `my_chat_member`
*   Необходимо подписаться на обновление статуса участника чата (самого бота).
*   **Сценарий "Блокировка":**
    *   Telegram присылает событие, что статус изменился на `kicked` (пользователь заблокировал бота).
    *   **Действие:** Найти пользователя в БД и установить флаг `is_active = False`. Удалять запись из БД **нельзя** (нужна история).
*   **Сценарий "Разблокировка":**
    *   Telegram присылает событие, что статус изменился на `member` (пользователь разблокировал бота / нажал "Start").
    *   **Действие:** Установить флаг `is_active = True`.

---

## 4. Логирование и Обработка Ошибок

*   Использовать структурированное логирование (например, `structlog` или настроенный `logging`).
*   Каждый запрос должен логироваться с указанием `user_id`, чтобы можно было отследить путь конкретного пользователя по логам.
*   Ошибки БД не должны "ронять" бота. Бот должен перехватывать исключения и, при необходимости, отправлять пользователю сообщение "Что-то пошло не так", логируя трейсбэк.

---

## ✅ Критерии Приемки (Definition of Done)

1.  [x] Бот запускается (Long Polling) и подключается к NATS.
2.  [x] При отправке команды `/start` новым пользователем:
    *   Бот отвечает.
    *   В базе данных появляется новая запись в таблице `users`.
3.  [x] При повторном написании сообщения существующим пользователем:
    *   В БД обновляется поле `updated_at`.
    *   Дубликаты записей не создаются.
4.  [x] При блокировке бота пользователем:
    *   В консоли/логах видно событие блокировки.
    *   В базе данных у этого пользователя поле `is_active` меняется на `False`.
5.  [x] Хендлеры получают объект сессии БД (`AsyncSession`) как аргумент функции автоматически.