3.  Организовать **Dependency Injection (DI)**: обеспечить доступ к базе данных и API Telegram внутри изолированных задач.
4.  Создать точку входа для запуска процесса Воркера.

---

## 1. Архитектура Очереди (Infrastructure)

### 1.1. Брокер (Message Broker)
*   **Технология:** NATS (с использованием библиотеки `taskiq-nats`).
*   **Режим работы:** Рекомендуется использовать **JetStream** (если поддерживается библиотекой драйвера) или стандартный Core NATS для начала. JetStream критичен для продакшена, чтобы задачи не терялись при перезагрузке брокера.
*   **Конфигурация:** URL подключения должен браться из `Dynaconf`.

### 1.2. Бэкенд Результатов (Result Backend)
*   **Технология:** Redis (с использованием `taskiq-redis`).
*   **Назначение:** Хранить результаты выполнения функций (`return value`) и статусы (Success/Failed).
*   **TTL (Time To Live):** Настроить время жизни результатов (например, 1 час), чтобы Redis не забивался устаревшими данными о выполненных рассылках.

### 1.3. Сериализация
*   **Технология:** `ormsgpack`.
*   **Требование:** Использовать этот формат вместо стандартного JSON/Pickle для упаковки аргументов задач и результатов. Это обеспечит максимальную скорость передачи данных между Ботом и Воркером.

---

## 2. Контекст и Зависимости (Dependency Injection)

Задачи Taskiq выполняются в отдельном процессе/контейнере, поэтому у них нет доступа к переменным из памяти процесса Бота. Необходимо явно "внедрить" зависимости.

### 2.1. Контекст Базы Данных
*   Настроить механизм (через Middleware Taskiq или Startup-событие), который создает **фабрику сессий SQLAlchemy** внутри воркера.
*   Каждая задача, работающая с БД, должна получать свежую сессию и корректно её закрывать после выполнения.

### 2.2. Контекст Бота
*   Воркеру часто нужно отправлять сообщения (например, "Отчет готов").
*   Необходимо инициализировать экземпляр `Bot` внутри процесса воркера и пробросить его в контекст задач.

---

## 3. Определение Задач (Task Definition)

### 3.1. Структура
*   Задачи должны быть декорированы специальным декоратором брокера (например, `@broker.task`).
*   Аргументы функций задач должны быть **сериализуемыми** (int, string, pydantic models). Нельзя передавать объекты соединений, файлы или сложные классы.

### 3.2. Идемпотентность (Best Practice)
*   Задачи должны проектироваться так, чтобы их повторное выполнение (в случае сбоя сети и ретрая) не ломало данные.

---

## 4. Запуск Воркера (Worker Entrypoint)

Необходимо создать отдельный файл/скрипт (например, `app/worker.py`), который будет служить точкой входа для процесса обработки задач.

### 4.1. Жизненный цикл Воркера
1.  **Startup:**
    *   Загрузка конфигурации.
    *   Инициализация брокера NATS.
    *   Инициализация подключений к БД и Redis.
    *   "Прогрев" кэшей (если нужно).
2.  **Processing:**
    *   Прослушивание очереди.
    *   Выполнение задач.
3.  **Shutdown:**
    *   Корректное закрытие соединений с БД, NATS и Redis (Graceful Shutdown), чтобы не прерывать задачи на полуслове.

---

## ✅ Критерии Приемки (Definition of Done)

1.  [x] Написан код конфигурации Брокера (NATS) и Бэкенда (Redis).
2.  [x] Создан скрипт запуска воркера (`app/worker.py`).
3.  [x] Создана тестовая задача (например, `test_di_task`).
4.  [x] **Интеграционный тест:**
    *   Запущен контейнер NATS и Redis.
    *   Запущен процесс Воркера.
    *   Запущен процесс Бота (или скрипт-продьюсер).
    *   Бот отправляет задачу -> Воркер пишет лог о выполнении -> Результат появляется в Redis.
5.  [x] Проверено внедрение зависимостей: Тестовая задача может сделать `SELECT` из базы данных, не вызывая ошибку подключения.